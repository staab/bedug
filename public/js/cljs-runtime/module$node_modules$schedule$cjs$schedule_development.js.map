{
"version":3,
"file":"module$node_modules$schedule$cjs$schedule_development.js",
"lineCount":13,
"mappings":"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",
"sources":["node_modules/schedule/cjs/schedule.development.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$schedule$cjs$schedule_development\"] = function(global,process,require,module,exports,shadow$shims) {\n/** @license React v16.5.2\n * schedule.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable no-var */\n\n// TODO: Currently there's only a single priority level, Deferred. Will add\n// additional priorities.\nvar DEFERRED_TIMEOUT = 5000;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar isPerformingWork = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar timeRemaining;\nif (hasNativePerformanceNow) {\n  timeRemaining = function () {\n    // We assume that if we have a performance timer that the rAF callback\n    // gets a performance timer value. Not sure if this is always true.\n    var remaining = getFrameDeadline() - performance.now();\n    return remaining > 0 ? remaining : 0;\n  };\n} else {\n  timeRemaining = function () {\n    // Fallback to Date.now()\n    var remaining = getFrameDeadline() - Date.now();\n    return remaining > 0 ? remaining : 0;\n  };\n}\n\nvar deadlineObject = {\n  timeRemaining: timeRemaining,\n  didTimeout: false\n};\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isPerformingWork) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest timeout in the list.\n  var timesOutAt = firstCallbackNode.timesOutAt;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelCallback();\n  }\n  requestCallback(flushWork, timesOutAt);\n}\n\nfunction flushFirstCallback(node) {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var previous = firstCallbackNode.previous;\n    firstCallbackNode = previous.next = next;\n    next.previous = previous;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  callback(deadlineObject);\n}\n\nfunction flushWork(didTimeout) {\n  isPerformingWork = true;\n  deadlineObject.didTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the timed out callbacks without yielding.\n      while (firstCallbackNode !== null) {\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.timesOutAt <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.timesOutAt <= currentTime);\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\n      }\n    }\n  } finally {\n    isPerformingWork = false;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled(firstCallbackNode);\n    } else {\n      isHostCallbackScheduled = false;\n    }\n  }\n}\n\nfunction unstable_scheduleWork(callback, options) {\n  var currentTime = exports.unstable_now();\n\n  var timesOutAt;\n  if (options !== undefined && options !== null && options.timeout !== null && options.timeout !== undefined) {\n    // Check for an explicit timeout\n    timesOutAt = currentTime + options.timeout;\n  } else {\n    // Compute an absolute timeout using the default constant.\n    timesOutAt = currentTime + DEFERRED_TIMEOUT;\n  }\n\n  var newNode = {\n    callback: callback,\n    timesOutAt: timesOutAt,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, sorted by its timeout.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled(firstCallbackNode);\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.timesOutAt > timesOutAt) {\n        // The new callback times out before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later timeout was found, which means the new\n      // callback has the latest timeout in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest timeout in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled(firstCallbackNode);\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_cancelScheduledWork(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestCallback;\nvar cancelCallback;\nvar getFrameDeadline;\n\nif (typeof window === 'undefined') {\n  // If this accidentally gets imported in a non-browser environment, fallback\n  // to a naive implementation.\n  var timeoutID = -1;\n  requestCallback = function (callback, absoluteTimeout) {\n    timeoutID = setTimeout(callback, 0, true);\n  };\n  cancelCallback = function () {\n    clearTimeout(timeoutID);\n  };\n  getFrameDeadline = function () {\n    return 0;\n  };\n} else if (window._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var impl = window._schedMock;\n  requestCallback = impl[0];\n  cancelCallback = impl[1];\n  getFrameDeadline = impl[2];\n} else {\n  if (typeof console !== 'undefined') {\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledCallback = null;\n  var isIdleScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isPerformingIdleWork = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  getFrameDeadline = function () {\n    return frameDeadline;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (timeoutTime !== -1 && timeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        return;\n      }\n    }\n\n    timeoutTime = -1;\n    var callback = scheduledCallback;\n    scheduledCallback = null;\n    if (callback !== null) {\n      isPerformingIdleWork = true;\n      try {\n        callback(didTimeout);\n      } finally {\n        isPerformingIdleWork = false;\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  requestCallback = function (callback, absoluteTimeout) {\n    scheduledCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isPerformingIdleWork) {\n      // If we're already performing idle work, an error must have been thrown.\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      window.postMessage(messageKey, '*');\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelCallback = function () {\n    scheduledCallback = null;\n    isIdleScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_scheduleWork = unstable_scheduleWork;\nexports.unstable_cancelScheduledWork = unstable_cancelScheduledWork;\n  })();\n}\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","ensureHostCallbackIsScheduled","isPerformingWork","timesOutAt","firstCallbackNode","isHostCallbackScheduled","cancelCallback","requestCallback","flushWork","flushFirstCallback","node","flushedNode","next","previous","callback","deadlineObject","didTimeout","currentTime","unstable_now","getFrameDeadline","Object","defineProperty","value","hasNativePerformanceNow","performance","now","timeRemaining","remaining","Date","localDate","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","rAFID","rAFTimeoutID","requestAnimationFrameWithTimeout","timestamp","ANIMATION_FRAME_TIMEOUT","Performance","exports.unstable_now","window","timeoutID","absoluteTimeout","_schedMock","impl","console","error","scheduledCallback","isIdleScheduled","timeoutTime","isAnimationFrameScheduled","isPerformingIdleWork","frameDeadline","previousFrameTime","activeFrameTime","messageKey","Math","random","toString","slice","addEventListener","idleTick","event","source","data","animationTick","rafTime","nextFrameTime","postMessage","unstable_scheduleWork","options","timeout","DEFERRED_TIMEOUT","newNode","unstable_cancelScheduledWork","callbackNode"]
}
